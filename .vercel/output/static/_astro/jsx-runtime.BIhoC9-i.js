import{r as d}from"./index.CYADgoF0.js";import{g as z,a as F}from"./i18nInstance.DBIXdvxg.js";const J=(e,t,n,a)=>{const r=[n,{code:t,...a||{}}];if(e?.services?.logger?.forward)return e.services.logger.forward(r,"warn","react-i18next::",!0);p(r[0])&&(r[0]=`react-i18next:: ${r[0]}`),e?.services?.logger?.warn?e.services.logger.warn(...r):console?.warn&&console.warn(...r)},j={},y=(e,t,n,a)=>{p(n)&&j[n]||(p(n)&&(j[n]=new Date),J(e,t,n,a))},L=(e,t)=>()=>{if(e.isInitialized)t();else{const n=()=>{setTimeout(()=>{e.off("initialized",n)},0),t()};e.on("initialized",n)}},C=(e,t,n)=>{e.loadNamespaces(t,L(e,n))},k=(e,t,n,a)=>{if(p(n)&&(n=[n]),e.options.preload&&e.options.preload.indexOf(t)>-1)return C(e,n,a);n.forEach(r=>{e.options.ns.indexOf(r)<0&&e.options.ns.push(r)}),e.loadLanguages(t,L(e,a))},M=(e,t,n={})=>!t.languages||!t.languages.length?(y(t,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:t.languages}),!0):t.hasLoadedNamespace(e,{lng:n.lng,precheck:(a,r)=>{if(n.bindI18n&&n.bindI18n.indexOf("languageChanging")>-1&&a.services.backendConnector.backend&&a.isLanguageChangingTo&&!r(a.isLanguageChangingTo,e))return!1}}),p=e=>typeof e=="string",$=e=>typeof e=="object"&&e!==null,q=d.createContext();class G{constructor(){this.usedNamespaces={}}addUsedNamespaces(t){t.forEach(n=>{this.usedNamespaces[n]||(this.usedNamespaces[n]=!0)})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const U=(e,t)=>{const n=d.useRef();return d.useEffect(()=>{n.current=e},[e,t]),n.current},O=(e,t,n,a)=>e.getFixedT(t,n,a),Y=(e,t,n,a)=>d.useCallback(O(e,t,n,a),[e,t,n,a]),H=(e,t={})=>{const{i18n:n}=t,{i18n:a,defaultNS:r}=d.useContext(q)||{},s=n||a||z();if(s&&!s.reportNamespaces&&(s.reportNamespaces=new G),!s){y(s,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const i=(l,f)=>p(f)?f:$(f)&&p(f.defaultValue)?f.defaultValue:Array.isArray(l)?l[l.length-1]:l,c=[i,{},!1];return c.t=i,c.i18n={},c.ready=!1,c}s.options.react?.wait&&y(s,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const u={...F(),...s.options.react,...t},{useSuspense:x,keyPrefix:w}=u;let o=r||s.options?.defaultNS;o=p(o)?[o]:o||["translation"],s.reportNamespaces.addUsedNamespaces?.(o);const g=(s.isInitialized||s.initializedStoreOnce)&&o.every(i=>M(i,s,u)),P=Y(s,t.lng||null,u.nsMode==="fallback"?o:o[0],w),S=()=>P,R=()=>O(s,t.lng||null,u.nsMode==="fallback"?o:o[0],w),[I,N]=d.useState(S);let T=o.join();t.lng&&(T=`${t.lng}${T}`);const _=U(T),m=d.useRef(!0);d.useEffect(()=>{const{bindI18n:i,bindI18nStore:c}=u;m.current=!0,!g&&!x&&(t.lng?k(s,t.lng,o,()=>{m.current&&N(R)}):C(s,o,()=>{m.current&&N(R)})),g&&_&&_!==T&&m.current&&N(R);const l=()=>{m.current&&N(R)};return i&&s?.on(i,l),c&&s?.store.on(c,l),()=>{m.current=!1,s&&i&&i?.split(" ").forEach(f=>s.off(f,l)),c&&s&&c.split(" ").forEach(f=>s.store.off(f,l))}},[s,T]),d.useEffect(()=>{m.current&&g&&N(S)},[s,w,g]);const h=[I,s,g];if(h.t=I,h.i18n=s,h.ready=g,g||!g&&!x)return h;throw new Promise(i=>{t.lng?k(s,t.lng,o,()=>i()):C(s,o,()=>i())})};var v={exports:{}},E={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var b;function W(){if(b)return E;b=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function n(a,r,s){var u=null;if(s!==void 0&&(u=""+s),r.key!==void 0&&(u=""+r.key),"key"in r){s={};for(var x in r)x!=="key"&&(s[x]=r[x])}else s=r;return r=s.ref,{$$typeof:e,type:a,key:u,ref:r!==void 0?r:null,props:s}}return E.Fragment=t,E.jsx=n,E.jsxs=n,E}var A;function X(){return A||(A=1,v.exports=W()),v.exports}var Q=X();export{Q as j,H as u};
